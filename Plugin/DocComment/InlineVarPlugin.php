<?php

namespace Drenso\PhanExtensions\Plugin\DocComment;

require_once __DIR__ . '/../../Helper/NamespaceChecker.php';

use Drenso\PhanExtensions\Helper\NamespaceChecker;
use Phan\Phan;
use Phan\CodeBase;
use Phan\Language\Element\Clazz;
use Phan\Language\Element\Comment;
use Phan\Language\UnionType;
use Phan\PluginV2;
use Phan\PluginV2\AnalyzeClassCapability;

class InlineVarPlugin extends PluginV2 implements AnalyzeClassCapability
{
  /** @var array<string,bool> - A file can have more than one class, even though that goes against PSRs. */
  private $analyzedFileSet;

  public function analyzeClass(CodeBase $codeBase, Clazz $class)
  {
    // Check the file ref
    $file = $class->getFileRef();
    if ($file->isPHPInternal()) return;

    $fileName = $file->getFile();
    // Save time: check files that are going to be analyzed. (Alternately, could look into PostAnalysisVisitor and putting the same code in visitClass/visitFunc
    if (Phan::isExcludedAnalysisFile($fileName)) {
      return;
    }
    if (array_key_exists($fileName, $this->analyzedFileSet)) {
      // TODO: Won't work with daemon mode without pcntl that well without new capabilities, but that's an edge case
      return;
    }
    $this->analyzedFileSet[$fileName] = true;
    $fileContents = file_get_contents($fileName);

    if (function_exists('token_get_all')) {
      $tokens = token_get_all($fileContents);
      // Set line number to found one
      $context = $class->getContext();
      $lineNumber = $context->getLineNumberStart();
      foreach ($tokens as $token) {
        if (!\is_array($token)) {
            return;
        }
        // Filter comment tokens
        if ($token[0] != T_COMMENT && $token[0] !== T_DOC_COMMENT) continue;

        $class->getContext()->withLineNumberStart($token[2]);

        // Retrieve errors
        $this->findUsages($codeBase, $class, $token[1]);

      }
      // Restore line number to prevent errors
      $context->withLineNumberStart($lineNumber);
    } else {
      // Forward complete file content
      $this->findUsages($codeBase, $class, $fileContents);
    }
  }

  // Copied from \Phan\Language\Element\Comment::param_comment_regex (without variadic/references for (at)param) with the following changes
  // 1. Make the name mandatory
  // 2. Make the union type mandatory
  // 3. Remove variadic/reference/param from the regex
  const var_comment_regex =
    '/@(?:phan-)?var\b\s*(' . UnionType::union_type_regex . ')\s*\\$' . Comment::WORD_REGEX . '/';

  /**
   * @param CodeBase $codeBase
   * @param Clazz $class
   * @param string $content
   */
  private function findUsages(CodeBase $codeBase, Clazz $class, string $content): void
  {
    \preg_match_all(self::var_comment_regex, $content, $matches);
    $results = $matches[1];
    foreach ($results as $match) {
      NamespaceChecker::checkPlugin($this, $codeBase, $class->getContext(), $match, "UndeclaredTypeInInlineVar",
          "The classlike {CLASS} in this \"var\" statement is undeclared (generated by InlineVar plugin)");
    }
  }
}

// Every plugin needs to return an instance of itself at the
// end of the file in which its defined.
return new InlineVarPlugin();
