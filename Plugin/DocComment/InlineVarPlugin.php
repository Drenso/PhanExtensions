<?php

namespace Drenso\PhanExtensions\Plugin\DocComment;

require_once __DIR__ . '/../../Helper/NamespaceChecker.php';

use Drenso\PhanExtensions\Helper\NamespaceChecker;
use Phan\Phan;
use Phan\CodeBase;
use Phan\Language\Element\Clazz;
use Phan\Language\UnionType;
use Phan\PluginV3;
use Phan\PluginV3\AnalyzeClassCapability;

class InlineVarPlugin extends PluginV3 implements AnalyzeClassCapability
{
  /**
   * @var array<string,bool> - A file can have more than one class, even though that goes against some style guides.
   *  So only analyze the file once, and assume there's only one namespace.
   */
  private $analyzedFileSet = [];

  /**
   * This regex contains a single pattern, which matches a valid PHP identifier.
   * (e.g. for variable names, magic property names, etc.)
   * This does not allow backslashes.
   *
   * Copied from Phan\Language\Element\Comment\Builder
   */
  const WORD_REGEX = '([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)';

  public function analyzeClass(CodeBase $codeBase, Clazz $class): void
  {
    // Check the file ref
    $file = $class->getFileRef();
    if ($file->isPHPInternal()) return;

    $fileName = $file->getFile();
    // Save time: skip files that won't be analyzed.
    if (Phan::isExcludedAnalysisFile($fileName)) {
      return;
    }
    if (array_key_exists($fileName, $this->analyzedFileSet)) {
      // TODO: Won't work with daemon mode without pcntl that well without new capabilities, but that's an edge case
      return;
    }
    $this->analyzedFileSet[$fileName] = true;
    $fileContents = file_get_contents($fileName);

    if (function_exists('token_get_all')) {
      $tokens = token_get_all($fileContents);
      // Set line number to found one
      $context = $class->getContext();
      $lineNumber = $context->getLineNumberStart();
      try {
        foreach ($tokens as $token) {
          if (!\is_array($token)) {
              continue;
          }
          // Filter comment tokens
          if ($token[0] != T_COMMENT && $token[0] !== T_DOC_COMMENT) continue;

          $class->getContext()->withLineNumberStart($token[2]);

          // Retrieve errors
          $this->findUsages($codeBase, $class, $token[1]);

        }
      } finally {
        // Restore line number to prevent errors
        $context->withLineNumberStart($lineNumber);
      }
    } else {
      // Forward complete file content
      $this->findUsages($codeBase, $class, $fileContents);
    }
  }

  // Copied from \Phan\Language\Element\Comment::param_comment_regex (without variadic/references for (at)param) with the following changes
  // 1. Make the name mandatory
  // 2. Make the union type mandatory
  // 3. Remove variadic/reference/param from the regex
  const var_comment_regex =
    '/@(?:phan-)?var\b\s*(' . UnionType::union_type_regex . ')\s*\\$' . self::WORD_REGEX . '/';

  /**
   * @param CodeBase $codeBase
   * @param Clazz $class
   * @param string $content
   */
  private function findUsages(CodeBase $codeBase, Clazz $class, string $content)
  {
    \preg_match_all(self::var_comment_regex, $content, $matches);
    $results = $matches[1];
    foreach ($results as $match) {
      NamespaceChecker::checkPlugin($this, $codeBase, $class->getContext(), $match, "UndeclaredTypeInInlineVar",
          "The classlike {CLASS} in this \"var\" statement is undeclared (generated by InlineVar plugin)");
    }
  }
}

// Every plugin needs to return an instance of itself at the
// end of the file in which its defined.
return new InlineVarPlugin();
